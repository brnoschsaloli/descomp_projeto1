tmp(0) := x"4" & '0' & x"09";	-- LDI $9			#Carrega o acumulador com o valor 9
tmp(1) := x"5" & '1' & x"20";	-- STA @288		#Armazena o valor do acumulador em HEX0
tmp(2) := x"5" & '1' & x"21";	-- STA @289		#Armazena o valor do acumulador em HEX1
tmp(3) := x"5" & '1' & x"22";	-- STA @290		#Armazena o valor do acumulador em HEX2
tmp(4) := x"5" & '1' & x"23";	-- STA @291		#Armazena o valor do acumulador em HEX3
tmp(5) := x"5" & '1' & x"24";	-- STA @292		#Armazena o valor do acumulador em HEX4
tmp(6) := x"5" & '1' & x"25";	-- STA @293		#Armazena o valor do acumulador em HEX5
tmp(7) := x"0" & '0' & x"00";	-- NOP
tmp(8) := x"4" & '0' & x"00";	-- LDI $0			#Carrega o acumulador com o valor 0
tmp(9) := x"5" & '1' & x"00";	-- STA @256		#Armazena o valor do bit0 do acumulador no LDR0 ~ LEDR7
tmp(10) := x"5" & '1' & x"01";	-- STA @257		#Armazena o valor do bit0 do acumulador no LDR8
tmp(11) := x"5" & '1' & x"02";	-- STA @258		#Armazena o valor do bit0 do acumulador no LDR9
tmp(12) := x"0" & '0' & x"00";	-- NOP
tmp(13) := x"4" & '0' & x"09";	-- LDI $9			#Carrega o acumulador com o valor 9
tmp(14) := x"5" & '0' & x"00";	-- STA @0			#Armazena o valor do acumulador em MEM[0] (unidades)
tmp(15) := x"5" & '0' & x"01";	-- STA @1			#Armazena o valor do acumulador em MEM[1] (dezenas)
tmp(16) := x"5" & '0' & x"02";	-- STA @2			#Armazena o valor do acumulador em MEM[2] (centenas)
tmp(17) := x"5" & '0' & x"03";	-- STA @3			#Armazena o valor do acumulador em MEM[3] (milhares)
tmp(18) := x"5" & '0' & x"04";	-- STA @4			#Armazena o valor do acumulador em MEM[4] (dezenas de milhares)
tmp(19) := x"5" & '0' & x"05";	-- STA @5			#Armazena o valor do acumulador em MEM[5] (centenas de milhares)
tmp(20) := x"5" & '0' & x"06";	-- STA @6			#Armazena o valor do acumulador em MEM[6] (flag inibir contagem)
tmp(21) := x"0" & '0' & x"00";	-- NOP
tmp(22) := x"5" & '1' & x"FF";	-- STA @511		#Limpa a leitura do botão zero
tmp(23) := x"5" & '1' & x"FE";	-- STA @510		#Limpa a leitura do botão um
tmp(24) := x"0" & '0' & x"00";	-- NOP		
tmp(25) := x"1" & '1' & x"60";	-- LDA @352		#Carrega o acumulador com a leitura do botão KEY0
tmp(26) := x"C" & '0' & x"01";	-- ANDi $1			#Utiliza a máscara b0000_0001 para limpar todos os bits menos o bit 0
tmp(27) := x"D" & '0' & x"00";	-- CEQi $0			#Compara com constante 0
tmp(28) := x"7" & '0' & x"1F";	-- JEQ @31		#Desvia se igual a 0 (botão não foi pressionado)
tmp(29) := x"9" & '0' & x"29";	-- JSR @41		#O botão foi pressionado, chama a sub-rotina de incremento
tmp(30) := x"0" & '0' & x"00";	-- NOP 			#Retorno da sub-rotina de incremento
tmp(31) := x"9" & '0' & x"5A";	-- JSR @90 	#Escreve o valor das váriaveis de contagem nos displays
tmp(32) := x"0" & '0' & x"00";	-- NOP			#Retorno da sub-rotina de salvar nos displays
tmp(33) := x"1" & '1' & x"64";	-- LDA @356		#Carrega o acumulador com a leitura do botão FPGA_RESET
tmp(34) := x"C" & '0' & x"01";	-- ANDi $1			#Utiliza a máscara b0000_0001 para limpar todos os bits menos o bit 0
tmp(35) := x"D" & '0' & x"01";	-- CEQi $1			#Compara com constante 1
tmp(36) := x"7" & '0' & x"26";	-- JEQ @38		#Desvia se igual a 1 (botão não foi pressionado)
tmp(37) := x"9" & '0' & x"67";	-- JSR @103		#O botão foi pressionado, chama a sub-rotina de reset
tmp(38) := x"0" & '0' & x"00";	-- NOP			#Retorno da sub-rotina de reset
tmp(39) := x"6" & '0' & x"18";	-- JMP @24		#Fecha o laço principal, faz uma nova leitura de KEY0
tmp(40) := x"0" & '0' & x"00";	-- NOP
tmp(41) := x"5" & '1' & x"FF";	-- STA @511		#Limpa a leitura do botão
tmp(42) := x"1" & '0' & x"09";	-- LDA @9			#Carrega o valor de MEM[6] (flag inibir contagem)
tmp(43) := x"D" & '0' & x"00";	-- CEQi $0			#Compara o valor com constante 0
tmp(44) := x"7" & '0' & x"2E";	-- JEQ @46
tmp(45) := x"A" & '0' & x"00";	-- RET
tmp(46) := x"1" & '0' & x"00";	-- LDA @0			#Carrega o valor de MEM[0] (contador)
